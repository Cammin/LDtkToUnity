using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;
using Debug = UnityEngine.Debug;

#if LDTK_UNITY_ASEPRITE && UNITY_2021_3_OR_NEWER
using UnityEditor.U2D.Aseprite;
#endif

#if UNITY_2020_2_OR_NEWER
using UnityEditor.AssetImporters;
#else
using UnityEditor.Experimental.AssetImporters;
#endif

namespace LDtkUnity.Editor
{
    /// <summary>
    /// This importer is for generating everything that's related to a tileset definition.
    /// This is generated by the project importer.
    /// This has no dependency back to the project importer, only the texture it references.
    /// </summary>
    [HelpURL(LDtkHelpURL.IMPORTER_LDTK_TILESET)]
    [ScriptedImporter(LDtkImporterConsts.TILESET_VERSION, LDtkImporterConsts.TILESET_EXT, LDtkImporterConsts.TILESET_ORDER)]
    internal sealed partial class LDtkTilesetImporter : LDtkJsonImporter<LDtkTilesetFile>
    {
        public const string PIXELS_PER_UNIT = nameof(_pixelsPerUnit);
        public const string OVERRIDE_TEXTURE = nameof(_overrideTexture);
        
        [SerializeField] internal int _pixelsPerUnit = -1;
        [SerializeField] internal LazyLoadReference<Texture2D> _overrideTexture;

        /// <summary>
        /// Holds onto all the standard grid-sized tiles. This serializes the sprite's changed settings between reimports, like pivot or physics shape.
        /// </summary>
        [SerializeField] internal List<LDtkSpriteRect> _sprites = new List<LDtkSpriteRect>();
        
        /// <summary>
        /// Any sprites that were defined from entity/level fields.
        /// It's separate because we don't want to draw them in the sprite editor window, or otherwise make them configurable.
        /// Also, because they won't have tilemap assets generated for them anyway, as their size wouldn't fit in the tilemap.
        /// </summary>
        private List<LDtkSpriteRect> _additionalTiles = new List<LDtkSpriteRect>();
        
        [SerializeField] internal SecondarySpriteTexture[] _secondaryTextures;
    
        private Texture2D _cachedExternalTex;
        private Texture2D _cachedTex;
        private int _overrideTextureMultiplier = 1;

        //serializing so that it's loaded by separate levels more efficiently
        [SerializeField] private LDtkArtifactAssetsTileset _artifacts;

        /// <summary>
        /// filled by deserializing
        /// </summary>
        private LDtkTilesetDefinitionWrapper _definition;
        private TilesetDefinition _json;
        
#if LDTK_UNITY_ASEPRITE && UNITY_2021_3_OR_NEWER
        private AsepriteImporter _srcAsepriteImporter;
#endif
        private TextureImporter _srcTextureImporter;
        private LDtkTilesetFile _tilesetFile;
        private string _texturePath;
        
        
        public static string[] _previousDependencies;
        protected override string[] GetGatheredDependencies() => _previousDependencies;


        //this will run upon standard reset, but also upon the meta file generation during the first import
        private void Reset()
        {
            LDtkPpuInitializer ppu = new LDtkPpuInitializer(_pixelsPerUnit, GetProjectPath(), assetPath);
            if (ppu.OnResetImporter())
            {
                _pixelsPerUnit = ppu.PixelsPerUnit;
                EditorUtility.SetDirty(this);
                SaveAndReimport();
            }
        }

        private static string[] GatherDependenciesFromSourceFile(string path)
        {
            if (LDtkPrefs.VerboseLogging)
            {
                LDtkDebug.Log($"GatherDependenciesFromSourceFile Tileset {path}");
            }

            //this depends on the texture
            //todo add a digger for getting the RelPath
            LDtkProfiler.BeginWriting($"GatherDependenciesFromSourceFile/{Path.GetFileName(path)}");
            string texPath = PathToTexture(path);
            texPath = !File.Exists(texPath) ? string.Empty : texPath;
            _previousDependencies = string.IsNullOrEmpty(texPath) ? Array.Empty<string>() : new []{texPath};
            LDtkProfiler.EndWriting();
            
            return _previousDependencies;
        }

        protected override void Import()
        {
            LDtkProfiler.BeginSample("DeserializeAndAssign");
            if (!DeserializeAndAssign())
            {
                LDtkProfiler.EndSample();
                FailImport();
                return;
            }
            LDtkProfiler.EndSample();

            //it's possible to select an empty tileset in LDtk
            if (IsNullTileset())
            {
                ImportContext.AddObjectToAsset("texture", new Texture2D(0,0), LDtkIconUtility.LoadTilesetFileIcon());
                return;
            }
            
            LDtkProfiler.BeginSample("GetTextureImporterPlatformSettings");
            TextureImporterPlatformSettings platformSettings = GetTextureImporterPlatformSettings();
            LDtkProfiler.EndSample();
            
            LDtkProfiler.BeginSample("CorrectTheTexture");
            //we're not auto-changing the textures because trying to make the changes via multi-selection doesnt work well. Could do some auto fixup for the texture maybe?
            if (HasTextureIssue(platformSettings))
            {
                LDtkProfiler.EndSample();
                FailImport();
                return;
            }
            LDtkProfiler.EndSample();
            
            LDtkProfiler.BeginSample("SetPixelsPerUnit");
            LDtkPpuInitializer ppu = new LDtkPpuInitializer(_pixelsPerUnit, GetProjectPath(), assetPath);
            if (ppu.OnResetImporter())
            {
                _pixelsPerUnit = ppu.PixelsPerUnit;
                EditorUtility.SetDirty(this);
            }
            LDtkProfiler.EndSample();
            
            LDtkProfiler.BeginSample("GetStandardSpriteRectsForDefinition");
            var rects = ReadSourceRectsFromJsonDefinition(_definition.Def);
            LDtkProfiler.EndSample();

            LDtkProfiler.BeginSample("ReformatRectMetaData");
            if (ReformatRectMetaData(rects))
            {
                EditorUtility.SetDirty(this);
            }
            LDtkProfiler.EndSample();

            LDtkProfiler.BeginSample("ReformatAdditionalTiles");
            ReformatAdditionalTiles();
            LDtkProfiler.EndSample();

            LDtkProfiler.BeginSample("PrepareGenerate");
            if (!PrepareAndGenerateTexture(platformSettings, out TextureGenerationOutput output))
            {
                FailImport();
                LDtkProfiler.EndSample();
                return;
            }
            LDtkProfiler.EndSample();

            Texture2D outputTexture = output.texture;
            if (outputTexture == null)
            {
                Logger.LogError("No Texture was generated. Possibly because it failed to generate texture.");
                FailImport();
                return;
            }
            if (output.sprites.IsNullOrEmpty())
            {
                Logger.LogError("No Sprites are generated. ");
                FailImport();
                return;
            }
            if (!string.IsNullOrEmpty(output.importInspectorWarnings))
            {
                Logger.LogWarning(output.importInspectorWarnings);
            }
            if (output.importWarnings != null)
            {
                foreach (var warning in output.importWarnings)
                {
                    Logger.LogWarning(warning);
                }
            }
            if (output.thumbNail == null)
            {
                Logger.LogWarning("Thumbnail generation fail");
            }
            
            outputTexture.name = AssetName;
            
            LDtkProfiler.BeginSample("MakeAndCacheArtifacts");
            _artifacts = MakeAndCacheArtifacts(output);
            LDtkProfiler.EndSample();

            ImportContext.AddObjectToAsset("artifactCache", _artifacts, (Texture2D)LDtkIconUtility.GetUnityIcon("Tilemap"));
            ImportContext.AddObjectToAsset("texture", outputTexture, LDtkIconUtility.LoadTilesetFileIcon());
            ImportContext.AddObjectToAsset("tilesetFile", _tilesetFile, LDtkIconUtility.LoadTilesetIcon());
            
            ImportContext.SetMainObject(outputTexture);

            LDtkTilemapColliderReset.TilemapColliderTileUpdate();
        }

        private void ReformatAdditionalTiles()
        {
            Debug.Assert(_definition != null);
            //Debug.Assert();
            
            var additionalRects = _definition.Rects;
            if (additionalRects.IsNullOrEmpty())
            {
                return;
            }

            _additionalTiles.Clear();
            for (int i = _additionalTiles.Count; i < additionalRects.Count; i++)
            {
                Rect rect = additionalRects[i].ToRect();

                Rect scaledRect = rect;
                scaledRect.x *= _overrideTextureMultiplier;
                scaledRect.y *= _overrideTextureMultiplier;
                scaledRect.width *= _overrideTextureMultiplier;
                scaledRect.height *= _overrideTextureMultiplier;
                
                scaledRect = LDtkCoordConverter.ImageSlice(scaledRect, _json.PxHei);
                
                LDtkSpriteRect newRect = new LDtkSpriteRect
                {
                    border = Vector4.zero,
                    pivot = new Vector2(0.5f, 0.5f),
                    alignment = SpriteAlignment.Center,
                    rect = scaledRect,
                    spriteID = GUID.Generate(),
                    name = MakeAssetName()
                };
                _additionalTiles.Add(newRect);
                
                string MakeAssetName()
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append(_json.Identifier);
                    sb.Append('_');
                    sb.Append(rect.x);
                    sb.Append('_');
                    sb.Append(rect.y);
                    sb.Append('_');
                    sb.Append(rect.width);
                    sb.Append('_');
                    sb.Append(rect.height);
                    return sb.ToString();
                }
            }
            
            Debug.Assert(_additionalTiles.Count == additionalRects.Count);
        }

        

        private TextureImporterSettings GetTextureImporterSettings()
        {
            TextureImporterSettings importerSettings = new TextureImporterSettings();
#if LDTK_UNITY_ASEPRITE && UNITY_2021_3_OR_NEWER
            if (_srcAsepriteImporter)
            {
                _srcAsepriteImporter.ReadTextureSettings(importerSettings);
            }
            else
#endif
            {
                _srcTextureImporter.ReadTextureSettings(importerSettings);
            }
            return importerSettings;
        }

        private TextureImporterPlatformSettings GetTextureImporterPlatformSettings()
        {
#if LDTK_UNITY_ASEPRITE && UNITY_2021_3_OR_NEWER
            if (_srcAsepriteImporter)
            {
                return _srcAsepriteImporter.GetImporterPlatformSettings(EditorUserBuildSettings.activeBuildTarget);
            }
#endif
            
            string platform = EditorUserBuildSettings.activeBuildTarget.ToString();
            TextureImporterPlatformSettings platformSettings = _srcTextureImporter.GetPlatformTextureSettings(platform);
            return platformSettings.overridden ? platformSettings : _srcTextureImporter.GetDefaultPlatformTextureSettings();
        }

        private bool DeserializeAndAssign()
        {
            //deserialize first. required for the path to the texture importer 
            try
            {
                _definition = FromJson<LDtkTilesetDefinitionWrapper>();
                _json = _definition.Def;
            }
            catch (Exception e)
            {
                Logger.LogError(e.ToString());
                return false;
            }
            
            if (IsNullTileset())
            {
                return true;
            }
            
            LDtkProfiler.BeginSample("CacheTextureImporterOrAsepriteImporter");
            if (!CacheTextureImporterOrAsepriteImporter())
            {
                LDtkProfiler.EndSample();
                return false;
            }
            LDtkProfiler.EndSample();

            LDtkProfiler.BeginSample("AddTilesetFileSubAsset");
            _tilesetFile = ReadAssetText();
            _tilesetFile.name = _tilesetFile.name.Insert(0, "_");
            LDtkProfiler.EndSample();
            
            if (_tilesetFile == null)
            {
                Logger.LogError("Tried to build tileset, but the tileset json ScriptableObject was null");
                return false;
            }
            
            return true;
        }
        
        private bool ReformatDefinitionForOverrideTexture()
        {
            if (_overrideTexture.isBroken)
            {
                return true;
            }
            Texture2D overrideTex = _overrideTexture.asset;
            if (overrideTex == null)
            {
                return true;
            }
            
            if (!IsResolutionMultiple(overrideTex.width, overrideTex.height, _json.PxWid, _json.PxHei, out _overrideTextureMultiplier))
            {
                Logger.LogError("The override texture's dimensions are not a multiple of the source tileset's size. " +
                                $"The override texture's dimensions are {overrideTex.width}x{overrideTex.height}, " +
                                $"while the tileset's cell size is {_json.PxWid}x{_json.PxHei}. " +
                                "Please ensure that the override texture's dimensions are a multiple of the source tileset's size.");
                return false;
            }
            
            _json.TileGridSize *= _overrideTextureMultiplier;
            _json.Padding *= _overrideTextureMultiplier;
            _json.Spacing *= _overrideTextureMultiplier;
            
            _json.PxWid = overrideTex.width;
            _json.PxHei = overrideTex.height;

            string projectPath = GetProjectPath();
            projectPath = LDtkPathUtility.AssetsPathToAbsolutePath(projectPath);
            string overrideTexturePath = AssetDatabase.GetAssetPath(overrideTex);
            overrideTexturePath = LDtkPathUtility.AssetsPathToAbsolutePath(overrideTexturePath);
            _json.RelPath = LDtkPathUtility.GetRelativePath(projectPath, overrideTexturePath);
            return true;
        }

        public static bool IsResolutionMultiple(int width, int height, int baseWidth, int baseHeight, out int multiplier)
        {
            // Check if width and height are multiples of the base dimensions
            if (width % baseWidth != 0 || height % baseHeight != 0)
            {
                multiplier = 1;
                return false;
            }

            // Calculate the multiples, Check if the multiples are the same
            int widthMultiple = width / baseWidth;
            int heightMultiple = height / baseHeight;

            if (widthMultiple == heightMultiple)
            {
                multiplier = widthMultiple;
                return true;
            }

            multiplier = 1;
            return false;
        }

        private bool IsNullTileset()
        {
            return !_json.IsEmbedAtlas && _json.RelPath == null;
        }
        
        private bool CacheTextureImporterOrAsepriteImporter()
        {
            string texturePath = PathToTexture();

            //First check embed atlas
            if (_json.IsEmbedAtlas && texturePath.IsNullOrEmpty())
            {
                Logger.LogError($"Tried to build the internal icons \"{AssetName}\", But the internal icons was not assigned in Unity's project settings. " +
                                $"You can add the texture by going to Edit > Project Settings > LDtk To Unity");
                return false;
            }
            
            if (!_json.IsEmbedAtlas && _json.RelPath.Length == 0)
            {
                Logger.LogError($"The tileset relative path was empty! Try fixing the Tileset path in the LDtk editor for \"{assetPath}\"");
                return false;
            }

            if (!ReformatDefinitionForOverrideTexture())
            {
                return false;
            }
            
            //Then check aseprite
            if (LDtkRelativeGetterTilesetTexture.IsAsepriteAsset(texturePath))
            {
#if LDTK_UNITY_ASEPRITE && UNITY_2021_3_OR_NEWER
                _srcAsepriteImporter = (AsepriteImporter)GetAtPath(texturePath);
                if (_srcAsepriteImporter == null)
                {
                    Logger.LogError($"Tried to build tileset {AssetName}, but the aseprite importer was not found at \"{texturePath}\". Is this tileset asset in a folder relative to the LDtk project file? Ensure that it's relativity is maintained if the project was moved also.");
                    return false;
                }
#else
                string fileName = Path.GetFileName(texturePath);
                Logger.LogError($"Tried loading an aseprite file \"{fileName}\", but the aseprite importer is not installed or below version 1.0.0. Add: com.unity.2d.aseprite. Requires Unity 2021.3.15 or newer");
                return false;
#endif
            }
            else
            {
                _srcTextureImporter = (TextureImporter)GetAtPath(texturePath);
                if (_srcTextureImporter == null)
                {
                    Logger.LogError($"Tried to build tileset {AssetName}, but the texture importer was not found at \"{texturePath}\". Is this tileset asset in a folder relative to the LDtk project file? Ensure that it's relativity is maintained if the project was moved also.");
                    return false;
                }
            }
            
            return true;
        }
        
        private string PathToTexture()
        {
            if (!_overrideTexture.isBroken && _overrideTexture.asset != null)
            {
                return AssetDatabase.GetAssetPath(_overrideTexture.asset);
            }
            
            if (_json == null)
            {
                Logger.LogError("The tileset definition was null, so the path to the texture could not be found.");
                return null;
            }
            
            if (_json.IsEmbedAtlas)
            {
                string iconsPath = LDtkProjectSettings.InternalIconsTexturePath;
                return iconsPath.IsNullOrEmpty() ? string.Empty : iconsPath;
            }

            LDtkRelativeGetterTilesetTexture getter = new LDtkRelativeGetterTilesetTexture();
            string pathFrom = Path.Combine(assetPath, "..");
            pathFrom = LDtkPathUtility.CleanPath(pathFrom);
            string path = getter.GetPath(_json, pathFrom);
            return path;
        }
        
        /// <summary>
        /// Only use when needed, it performs a deserialize. look at optimizing if it's expensive
        /// </summary>
        private static string PathToTexture(string assetPath, TilesetDefinition def = null)
        {
            string overrideTexturePath = LDtkDependencyUtil.GetTilesetImporterOverrideTexturePath(assetPath);
            if (overrideTexturePath != null)
            {
                return overrideTexturePath;
            }
            
            if (def == null)
            {
                def = FromJson<LDtkTilesetDefinitionWrapper>(assetPath).Def;
            }
            
            if (def.IsEmbedAtlas)
            {
                string iconsPath = LDtkProjectSettings.InternalIconsTexturePath;
                return iconsPath.IsNullOrEmpty() ? string.Empty : iconsPath;
            }

            LDtkRelativeGetterTilesetTexture getter = new LDtkRelativeGetterTilesetTexture();
            string pathFrom = Path.Combine(assetPath, "..");
            pathFrom = LDtkPathUtility.CleanPath(pathFrom);
            string path = getter.GetPath(def, pathFrom);
            //Debug.Log($"relative from {pathFrom}. path of texture importer was {path}");
            return path;
        }

        private void ForceUpdateSpriteDataName(SpriteRect spr)
        {
            spr.name = $"{AssetName}_{spr.rect.x}_{spr.rect.y}_{spr.rect.width}_{spr.rect.height}";
        }
        
        private Texture2D LoadTex(bool forceLoad = false)
        {
            //this is important: in case the importer was destroyed via file delete
            if (this == null)
            {
                return null;
            }
            
            if (_cachedTex == null || forceLoad)
            {
                _cachedTex = AssetDatabase.LoadAssetAtPath<Texture2D>(assetPath);
            }
            return _cachedTex;
        }
        
        private LDtkSpriteRect GetSpriteData(GUID guid)
        {
            LDtkSpriteRect data = _sprites.FirstOrDefault(x => x.spriteID == guid);
            Debug.Assert(data != null, $"Sprite data not found for GUID: {guid.ToString()}");
            return data;
        }

        private LDtkSpriteRect GetSpriteData(string spriteName)
        {
            LDtkSpriteRect data = _sprites.FirstOrDefault(x => x.name == spriteName);
            Debug.Assert(data != null, $"Sprite data not found for name: {spriteName}");
            return data;
        }
    }
}