using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;
using Debug = UnityEngine.Debug;

#if LDTK_UNITY_ASEPRITE && UNITY_2021_3_OR_NEWER
using UnityEditor.U2D.Aseprite;
#endif

#if UNITY_2020_2_OR_NEWER
using UnityEditor.AssetImporters;
#else
using UnityEditor.Experimental.AssetImporters;
#endif

namespace LDtkUnity.Editor
{
    /// <summary>
    /// This importer is for generating everything that's related to a tileset definition.
    /// This is generated by the project importer.
    /// This has no dependency back to the project importer, only the texture it references.
    /// </summary>
    [HelpURL(LDtkHelpURL.IMPORTER_LDTK_TILESET)]
    [ScriptedImporter(LDtkImporterConsts.TILESET_VERSION, LDtkImporterConsts.TILESET_EXT, LDtkImporterConsts.TILESET_ORDER)]
    internal sealed partial class LDtkTilesetImporter : LDtkJsonImporter<LDtkTilesetFile>
    {
        public const string PIXELS_PER_UNIT = nameof(_pixelsPerUnit);
        
        [SerializeField] internal int _pixelsPerUnit = -1;

        /// <summary>
        /// Holds onto all the standard grid-sized tiles. This serializes the sprite's changed settings between reimports, like pivot or physics shape.
        /// </summary>
        [SerializeField] internal List<LDtkSpriteRect> _sprites = new List<LDtkSpriteRect>();
        
        /// <summary>
        /// Any sprites that were defined from entity/level fields.
        /// It's separate because we don't want to draw them in the sprite editor window, or otherwise make them configurable.
        /// Also, because they won't have tilemap assets generated for them anyway, as their size wouldn't fit in the tilemap.
        /// </summary>
        private List<LDtkSpriteRect> _additionalTiles = new List<LDtkSpriteRect>();
        
        [SerializeField] internal SecondarySpriteTexture[] _secondaryTextures;
    
        private Texture2D _cachedExternalTex;
        private Texture2D _cachedTex;

        //serializing so that it's loaded by separate levels more efficiently
        [SerializeField] private LDtkArtifactAssetsTileset _artifacts;

        /// <summary>
        /// filled by deserializing
        /// </summary>
        private LDtkTilesetDefinitionWrapper _definition;
        private TilesetDefinition _json;
        
#if LDTK_UNITY_ASEPRITE && UNITY_2021_3_OR_NEWER
        private AsepriteImporter _srcAsepriteImporter;
#endif
        private TextureImporter _srcTextureImporter;
        private LDtkTilesetFile _tilesetFile;
        private string _texturePath;
        
        
        public static string[] _previousDependencies;
        protected override string[] GetGatheredDependencies() => _previousDependencies;


        //this will run upon standard reset, but also upon the meta file generation during the first import
        private void Reset()
        {
            LDtkPpuInitializer ppu = new LDtkPpuInitializer(_pixelsPerUnit, GetProjectPath(), assetPath);
            if (ppu.OnResetImporter())
            {
                _pixelsPerUnit = ppu.PixelsPerUnit;
                EditorUtility.SetDirty(this);
                SaveAndReimport();
            }
        }

        private static string[] GatherDependenciesFromSourceFile(string path)
        {
            if (LDtkPrefs.VerboseLogging)
            {
                LDtkDebug.Log($"GatherDependenciesFromSourceFile Tileset {path}");
            }

            //this depends on the texture
            //todo add a digger for getting the RelPath
            LDtkProfiler.BeginWriting($"GatherDependenciesFromSourceFile/{Path.GetFileName(path)}");
            string texPath = PathToTexture(path);
            texPath = !File.Exists(texPath) ? string.Empty : texPath;
            _previousDependencies = string.IsNullOrEmpty(texPath) ? Array.Empty<string>() : new []{texPath};
            LDtkProfiler.EndWriting();
            
            return _previousDependencies;
        }

        protected override void Import()
        {
            LDtkProfiler.BeginSample("DeserializeAndAssign");
            if (!DeserializeAndAssign())
            {
                LDtkProfiler.EndSample();
                FailImport();
                return;
            }
            LDtkProfiler.EndSample();

            //it's possible to select an empty tileset in LDtk
            if (IsNullTileset())
            {
                ImportContext.AddObjectToAsset("texture", new Texture2D(0,0), LDtkIconUtility.LoadTilesetFileIcon());
                return;
            }
            
            LDtkProfiler.BeginSample("GetTextureImporterPlatformSettings");
            TextureImporterPlatformSettings platformSettings = GetTextureImporterPlatformSettings();
            LDtkProfiler.EndSample();
            
            LDtkProfiler.BeginSample("CorrectTheTexture");
            //we're not auto-changing the textures because trying to make the changes via multi-selection doesnt work well. Could do some auto fixup for the texture maybe?
            if (HasTextureIssue(platformSettings))
            {
                LDtkProfiler.EndSample();
                FailImport();
                return;
            }
            LDtkProfiler.EndSample();
            
            LDtkProfiler.BeginSample("SetPixelsPerUnit");
            LDtkPpuInitializer ppu = new LDtkPpuInitializer(_pixelsPerUnit, GetProjectPath(), assetPath);
            if (ppu.OnResetImporter())
            {
                _pixelsPerUnit = ppu.PixelsPerUnit;
                EditorUtility.SetDirty(this);
            }
            LDtkProfiler.EndSample();
            
            LDtkProfiler.BeginSample("GetStandardSpriteRectsForDefinition");
            var rects = ReadSourceRectsFromJsonDefinition(_definition.Def);
            LDtkProfiler.EndSample();

            LDtkProfiler.BeginSample("ReformatRectMetaData");
            if (ReformatRectMetaData(rects))
            {
                EditorUtility.SetDirty(this);
            }
            LDtkProfiler.EndSample();

            LDtkProfiler.BeginSample("ReformatAdditionalTiles");
            ReformatAdditionalTiles();
            LDtkProfiler.EndSample();

            LDtkProfiler.BeginSample("PrepareGenerate");
            if (!PrepareAndGenerateTexture(platformSettings, out TextureGenerationOutput output))
            {
                FailImport();
                LDtkProfiler.EndSample();
                return;
            }
            LDtkProfiler.EndSample();

            Texture2D outputTexture = output.texture;
            if (outputTexture == null)
            {
                Logger.LogError("No Texture was generated. Possibly because it failed to generate texture.");
                FailImport();
                return;
            }
            if (output.sprites.IsNullOrEmpty())
            {
                Logger.LogError("No Sprites are generated. ");
                FailImport();
                return;
            }
            if (!string.IsNullOrEmpty(output.importInspectorWarnings))
            {
                Logger.LogWarning(output.importInspectorWarnings);
            }
            if (output.importWarnings != null)
            {
                foreach (var warning in output.importWarnings)
                {
                    Logger.LogWarning(warning);
                }
            }
            if (output.thumbNail == null)
            {
                Logger.LogWarning("Thumbnail generation fail");
            }
            
            outputTexture.name = AssetName;
            
            LDtkProfiler.BeginSample("MakeAndCacheArtifacts");
            _artifacts = MakeAndCacheArtifacts(output);
            LDtkProfiler.EndSample();

            ImportContext.AddObjectToAsset("artifactCache", _artifacts, (Texture2D)LDtkIconUtility.GetUnityIcon("Tilemap"));
            ImportContext.AddObjectToAsset("texture", outputTexture, LDtkIconUtility.LoadTilesetFileIcon());
            ImportContext.AddObjectToAsset("tilesetFile", _tilesetFile, LDtkIconUtility.LoadTilesetIcon());
            
            ImportContext.SetMainObject(outputTexture);

            LDtkTilemapColliderReset.TilemapColliderTileUpdate();
        }

        private void ReformatAdditionalTiles()
        {
            Debug.Assert(_definition != null);
            //Debug.Assert();
            
            var additionalRects = _definition.Rects;
            if (additionalRects.IsNullOrEmpty())
            {
                return;
            }

            _additionalTiles.Clear();
            for (int i = _additionalTiles.Count; i < additionalRects.Count; i++)
            {
                var rect = _definition.Rects[i].ToRect();
                rect = LDtkCoordConverter.ImageSlice(rect, _definition.Def.PxHei);
                LDtkSpriteRect newRect = new LDtkSpriteRect
                {
                    border = Vector4.zero,
                    pivot = new Vector2(0.5f, 0.5f),
                    alignment = SpriteAlignment.Center,
                    rect = rect,
                    spriteID = GUID.Generate(),
                    name = MakeAssetName()
                };
                _additionalTiles.Add(newRect);
                
                string MakeAssetName()
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append(_definition.Def.Identifier);
                    sb.Append('_');
                    sb.Append(rect.x);
                    sb.Append('_');
                    sb.Append(rect.y);
                    sb.Append('_');
                    sb.Append(rect.width);
                    sb.Append('_');
                    sb.Append(rect.height);
                    return sb.ToString();
                }
            }
            
            Debug.Assert(_additionalTiles.Count == additionalRects.Count);
        }

        

        private TextureImporterSettings GetTextureImporterSettings()
        {
            TextureImporterSettings importerSettings = new TextureImporterSettings();
#if LDTK_UNITY_ASEPRITE && UNITY_2021_3_OR_NEWER
            if (_srcAsepriteImporter)
            {
                _srcAsepriteImporter.ReadTextureSettings(importerSettings);
            }
            else
#endif
            {
                _srcTextureImporter.ReadTextureSettings(importerSettings);
            }
            return importerSettings;
        }

        private TextureImporterPlatformSettings GetTextureImporterPlatformSettings()
        {
#if LDTK_UNITY_ASEPRITE && UNITY_2021_3_OR_NEWER
            if (_srcAsepriteImporter)
            {
                return _srcAsepriteImporter.GetImporterPlatformSettings(EditorUserBuildSettings.activeBuildTarget);
            }
#endif
            
            string platform = EditorUserBuildSettings.activeBuildTarget.ToString();
            TextureImporterPlatformSettings platformSettings = _srcTextureImporter.GetPlatformTextureSettings(platform);
            return platformSettings.overridden ? platformSettings : _srcTextureImporter.GetDefaultPlatformTextureSettings();
        }

        private bool DeserializeAndAssign()
        {
            //deserialize first. required for the path to the texture importer 
            try
            {
                _definition = FromJson<LDtkTilesetDefinitionWrapper>();
                _json = _definition.Def;
            }
            catch (Exception e)
            {
                Logger.LogError(e.ToString());
                return false;
            }
            
            if (IsNullTileset())
            {
                return true;
            }
            
            LDtkProfiler.BeginSample("CacheTextureImporterOrAsepriteImporter");
            if (!CacheTextureImporterOrAsepriteImporter())
            {
                LDtkProfiler.EndSample();
                return false;
            }
            LDtkProfiler.EndSample();

            LDtkProfiler.BeginSample("AddTilesetFileSubAsset");
            _tilesetFile = ReadAssetText();
            _tilesetFile.name = _tilesetFile.name.Insert(0, "_");
            LDtkProfiler.EndSample();
            
            if (_tilesetFile == null)
            {
                Logger.LogError("Tried to build tileset, but the tileset json ScriptableObject was null");
                return false;
            }
            
            return true;
        }

        private bool IsNullTileset()
        {
            return !_json.IsEmbedAtlas && _json.RelPath == null;
        }
        
        private bool CacheTextureImporterOrAsepriteImporter()
        {
            string path = PathToTexture(assetPath, _json);

            //First check embed atlas
            if (_json.IsEmbedAtlas && path.IsNullOrEmpty())
            {
                Logger.LogError($"Tried to build the internal icons \"{AssetName}\", But the internal icons was not assigned in Unity's project settings. " +
                                $"You can add the texture by going to Edit > Project Settings > LDtk To Unity");
                return false;
            }
            
            if (!_json.IsEmbedAtlas && _json.RelPath.Length == 0)
            {
                Logger.LogError($"The tileset relative path was empty! Try fixing the Tileset path in the LDtk editor for \"{assetPath}\"");
                return false;
            }
            

            //Then check aseprite
            if (LDtkRelativeGetterTilesetTexture.IsAsepriteAsset(path))
            {
#if LDTK_UNITY_ASEPRITE && UNITY_2021_3_OR_NEWER
                _srcAsepriteImporter = (AsepriteImporter)GetAtPath(path);
                if (_srcAsepriteImporter == null)
                {
                    Logger.LogError($"Tried to build tileset {AssetName}, but the aseprite importer was not found at \"{path}\". Is this tileset asset in a folder relative to the LDtk project file? Ensure that it's relativity is maintained if the project was moved also.");
                    return false;
                }
#else
                string fileName = Path.GetFileName(path);
                Logger.LogError($"Tried loading an aseprite file \"{fileName}\", but the aseprite importer is not installed or below version 1.0.0. Add: com.unity.2d.aseprite. Requires Unity 2021.3.15 or newer");
                return false;
#endif
            }
            else
            {
                _srcTextureImporter = (TextureImporter)GetAtPath(path);
                if (_srcTextureImporter == null)
                {
                    Logger.LogError($"Tried to build tileset {AssetName}, but the texture importer was not found at \"{path}\". Is this tileset asset in a folder relative to the LDtk project file? Ensure that it's relativity is maintained if the project was moved also.");
                    return false;
                }
            }
            
            return true;
        }

        /// <summary>
        /// Only use when needed, it performs a deserialize. look at optimizing if it's expensive
        /// </summary>
        private static string PathToTexture(string assetPath, TilesetDefinition def = null)
        {
            if (def == null)
            {
                def = FromJson<LDtkTilesetDefinitionWrapper>(assetPath).Def;
            }
            
            if (def.IsEmbedAtlas)
            {
                string iconsPath = LDtkProjectSettings.InternalIconsTexturePath;
                return iconsPath.IsNullOrEmpty() ? string.Empty : iconsPath;
            }

            LDtkRelativeGetterTilesetTexture getter = new LDtkRelativeGetterTilesetTexture();
            string pathFrom = Path.Combine(assetPath, "..");
            pathFrom = LDtkPathUtility.CleanPath(pathFrom);
            string path = getter.GetPath(def, pathFrom);
            //Debug.Log($"relative from {pathFrom}. path of texture importer was {path}");
            return path;
        }

        private void ForceUpdateSpriteDataName(SpriteRect spr)
        {
            spr.name = $"{AssetName}_{spr.rect.x}_{spr.rect.y}_{spr.rect.width}_{spr.rect.height}";
        }
        
        private Texture2D LoadTex(bool forceLoad = false)
        {
            //this is important: in case the importer was destroyed via file delete
            if (this == null)
            {
                return null;
            }
            
            if (_cachedTex == null || forceLoad)
            {
                _cachedTex = AssetDatabase.LoadAssetAtPath<Texture2D>(assetPath);
            }
            return _cachedTex;
        }
        
        private LDtkSpriteRect GetSpriteData(GUID guid)
        {
            LDtkSpriteRect data = _sprites.FirstOrDefault(x => x.spriteID == guid);
            Debug.Assert(data != null, $"Sprite data not found for GUID: {guid.ToString()}");
            return data;
        }

        private LDtkSpriteRect GetSpriteData(string spriteName)
        {
            LDtkSpriteRect data = _sprites.FirstOrDefault(x => x.name == spriteName);
            Debug.Assert(data != null, $"Sprite data not found for name: {spriteName}");
            return data;
        }
    }
}