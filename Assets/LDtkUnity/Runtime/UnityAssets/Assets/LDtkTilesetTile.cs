using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Tilemaps;

namespace LDtkUnity
{
    /// <summary>
    /// The tile used for AutoLayers and Tile layers in LDtk. It can have collision shapes configured from the tileset file's sprite editor.
    /// </summary>
    [HelpURL(LDtkHelpURL.SO_TILESET_TILE)]
    public sealed class LDtkTilesetTile : TileBase
    {
        [SerializeField] internal Sprite _sprite;
        [SerializeField] internal Tile.ColliderType _type = Tile.ColliderType.None;

        [SerializeField] internal List<string> _enumTagValues = new List<string>();
        [SerializeField, TextArea] internal string _customData = string.Empty;

        //todo animation system in sprite editor module later
        [Header("WIP")]
        [SerializeField] internal Sprite[] _animationSprites = Array.Empty<Sprite>();
        [SerializeField] internal float _animationSpeed = 1f;
        [SerializeField] internal float _animationStartTime;
        
        //todo also potentially add auto rule stuff for cool runtime art updates later

        public Sprite Sprite => _sprite;
        public Tile.ColliderType Type => _type;
        
        /// <summary>
        /// The enum tag values as strings. Opt to use <see cref="GetEnumTagValues{TEnum}"/> to get them formatted as it's enum-typed values
        /// </summary>
        public IReadOnlyList<string> EnumTagValues => _enumTagValues;
        public string CustomData => _customData;
        

        public override void GetTileData(Vector3Int position, ITilemap tilemap, ref TileData tileData)
        {
            tileData.colliderType = _type;
            tileData.sprite = _sprite;
            
            //make color full, the tilemap components themselves have the actual requested opacity set.
            tileData.color = Color.white;
        }
        
        public override bool GetTileAnimationData(Vector3Int position, ITilemap tilemap, ref TileAnimationData anim)
        {
            if (_animationSprites.Length <= 1)
            {
                return false;
            }
            
            anim.animatedSprites = _animationSprites;
            anim.animationSpeed = _animationSpeed;
            anim.animationStartTime = _animationStartTime;
            return true;
        }

        /// <summary>
        /// A helper method to get all of the enum values converted into it's generated C# type.
        /// </summary>
        /// <typeparam name="TEnum">Use an enum type that was generated by the project importer.</typeparam>
        /// <returns>The enum values convert</returns>
        public TEnum[] GetEnumTagValues<TEnum>() where TEnum : struct
        {
            Type type = typeof(TEnum);
            if (!type.IsEnum)
            {
                LDtkDebug.LogError($"Input type {type.Name} is not an enum");
                return Array.Empty<TEnum>();
            }

            TEnum[] enums = _enumTagValues.Select(enumTagValue =>
            {
                if (Enum.IsDefined(type, enumTagValue))
                {
                    return (TEnum)Enum.Parse(type, enumTagValue);
                }

                //Error scenario
                Array enumDefValues = Enum.GetValues(typeof(TEnum));
                List<string> stringValues = new List<string>();
                foreach (object value in enumDefValues)
                {
                    string stringValue = Convert.ToString(value);
                    stringValues.Add(stringValue);
                }

                string joined = string.Join("\", \"", stringValues);
                LDtkDebug.LogError($"C# enum \"{type.Name}\" does not define enum value \"{enumTagValue}\". Possible values are \"{joined}\"");
                return default;

            }).ToArray();
            return enums;
        }
    }
    
}