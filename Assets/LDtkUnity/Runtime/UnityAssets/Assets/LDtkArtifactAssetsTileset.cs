using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace LDtkUnity
{
    /// <summary>
    /// Stores the autogenerated tiles/sprites for tilesets.
    /// </summary>
    [HelpURL(LDtkHelpURL.SO_ARTIFACT_ASSETS)]
    public sealed class LDtkArtifactAssetsTileset : ScriptableObject
    {
        internal const string PROPERTY_SPRITE_LIST = nameof(_sprites);
        internal const string PROPERTY_TILE_LIST = nameof(_tiles);
        internal const string PROPERTY_ADDITIONAL_SPRITES = nameof(_additionalSprites);
        
        [SerializeField] internal List<Sprite> _sprites;
        [SerializeField] internal List<LDtkTilesetTile> _tiles;
        [SerializeField] internal List<Sprite> _additionalSprites;
        
        // There isn't an easy way to index additional shapes in an optimized way when it comes to serialization 

        /// <summary>
        /// Indexed by tile id
        /// </summary>
        public IReadOnlyList<Sprite> Sprites => _sprites;

        /// <summary>
        /// Indexed by tile id
        /// </summary>
        public IReadOnlyList<LDtkTilesetTile> Tiles => _tiles;
        
        /// <summary>
        /// These sprites are slices created from tile instances or any other situations that result in a larger area selection.
        /// Not indexed; Perform a lookup by comparing this list's rectangles.
        ///
        /// There are 8 possible sources of additional TilesetRectangle.
        /// 
        /// Instance-based possible sources of additional sprites are:
        /// - EntityInstance.Tile
        /// - EntityInstance.FieldInstances.Tile
        /// - Level.FieldInstances.Tile
        /// 
        /// Definition-based possible sources of additional sprites are:
        /// - AutoLayerRuleGroup.Icon
        /// - EntityDefinition.TileRect
        /// - EntityDefinition.UiTileRect
        /// - EnumValueDefinition.TileRect
        /// - IntGridValueDefinition.Tile
        /// </summary>
        public IReadOnlyList<Sprite> AdditionalSprites => _additionalSprites;

        internal Dictionary<Rect, Sprite> AllSpritesToConvertedDict()
        {
            //List<Sprite> sprites = _sprites.Concat(_additionalSprites).Distinct().ToList();

            Dictionary<Rect,Sprite> dict = new Dictionary<Rect, Sprite>();
            foreach (Sprite sprite in _sprites)
            {
                PutToDict(sprite);
            }
            foreach (Sprite sprite in _additionalSprites)
            {
                PutToDict(sprite);
            }
            return dict;

            void PutToDict(Sprite sprite)
            {
                Rect convertedRect = LDtkCoordConverter.ImageSlice(sprite.rect, sprite.texture.height);

                if (!dict.ContainsKey(convertedRect))
                {
                    dict.Add(convertedRect, sprite);
                }
            }
        }
        internal Dictionary<Rect, Sprite> SpritesToDict()
        {
            return _sprites.ToDictionary(sprite => sprite.rect);
        }
        internal Dictionary<Rect, Sprite> AdditionalSpritesToDict()
        {
            return _additionalSprites.ToDictionary(sprite => sprite.rect);
        }
        
        /// <summary>
        /// This tries iterating over every possible coordinate to track down a tileset index.
        /// Is only able to check for tiles that are the same size as GridSize, no additional sprites.
        /// </summary>
        internal Sprite GetAdditionalSpriteForRectCoord(Rect rect, TilesetDefinition def)
        {
            int i = LDtkCoordConverter.TilesetSliceIndex(rect, def);
            if (i == -1)
            {
                return null;
            }

            return _sprites[i];
        }
        
        internal Sprite GetAdditionalSpriteForRect(Rect rect, int textureHeight)
        {
            return _additionalSprites.FirstOrDefault(p => p.rect == LDtkCoordConverter.ImageSlice(rect, textureHeight));
        }
    }
}