using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace LDtkUnity
{
    /// <summary>
    /// Stores the autogenerated tiles/sprites for tilesets.
    /// </summary>
    [HelpURL(LDtkHelpURL.SO_ARTIFACT_ASSETS)]
    public sealed class LDtkArtifactAssetsTileset : ScriptableObject
    {
        internal const string PROPERTY_SPRITE_LIST = nameof(_sprites);
        internal const string PROPERTY_TILE_LIST = nameof(_tiles);
        internal const string PROPERTY_ADDITIONAL_SPRITES = nameof(_additionalSprites);

        [SerializeField] internal int _overrideTextureMultiplier = 1;
        [SerializeField] internal Sprite[] _sprites;
        [SerializeField] internal LDtkTilesetTile[] _tiles;
        [SerializeField] internal Sprite[] _additionalSprites;
        
        // There isn't an easy way to index additional shapes in an optimized way when it comes to serialization 

        /// <summary>
        /// Indexed by tile id. Sprites can be null if all the tile's pixels were empty
        /// </summary>
        public IReadOnlyList<Sprite> Sprites => _sprites;

        /// <summary>
        /// Indexed by tile id
        /// </summary>
        public IReadOnlyList<LDtkTilesetTile> Tiles => _tiles;
        
        /// <summary>
        /// These sprites are slices created from tile instances or any other situations that result in a larger area selection.
        /// Not indexed; Perform a lookup by comparing this list's rectangles.
        ///
        /// There are 8 possible sources of additional TilesetRectangle.
        /// 
        /// Instance-based possible sources of additional sprites are:
        /// - EntityInstance.Tile
        /// - EntityInstance.FieldInstances.Tile
        /// - Level.FieldInstances.Tile
        /// 
        /// Definition-based possible sources of additional sprites are:
        /// - AutoLayerRuleGroup.Icon
        /// - EntityDefinition.TileRect
        /// - EntityDefinition.UiTileRect
        /// - EnumValueDefinition.TileRect
        /// - IntGridValueDefinition.Tile
        /// </summary>
        public IReadOnlyList<Sprite> AdditionalSprites => _additionalSprites;

        internal Dictionary<Rect, Sprite> AllSpritesToConvertedDict()
        {
            int capacity = _sprites.Length + _additionalSprites.Length;
            Dictionary<Rect,Sprite> dict = new Dictionary<Rect, Sprite>(capacity);
            foreach (Sprite sprite in _sprites)
            {
                //sprite could be null due to clear pixels
                if (sprite == null)
                {
                    continue;
                }
                Rect convertedRect = LDtkCoordConverter.ImageSlice(sprite.rect, sprite.texture.height);
                ScaleDown(ref convertedRect);
                dict.Add(convertedRect, sprite);
            }
            foreach (Sprite sprite in _additionalSprites)
            {
                Rect convertedRect = LDtkCoordConverter.ImageSlice(sprite.rect, sprite.texture.height);
                ScaleDown(ref convertedRect);
                if (!dict.ContainsKey(convertedRect))
                {
                    dict.Add(convertedRect, sprite);
                }
            }
            return dict;
        }
        
        /// <summary>
        /// This tries iterating over every possible coordinate to track down a tileset index.
        /// Is only able to check for tiles that are the same size as GridSize, no additional sprites.
        /// </summary>
        internal Sprite GetAdditionalSpriteForRectCoord(Rect rect, TilesetDefinition def)
        {
            int i = LDtkCoordConverter.TilesetSliceIndex(rect, def);
            if (i == -1)
            {
                return null;
            }

            return _sprites[i];
        }
        
        /// <summary>
        /// <seealso cref="LDtkDefinitionObjectsCache.GetSpriteForTilesetRectangle"/>
        /// </summary>
        internal Sprite FindAdditionalSpriteForRect(Rect smallRect, int textureHeight)
        {
            textureHeight *= _overrideTextureMultiplier;
            ScaleUp(ref smallRect);

            foreach (Sprite additionalSprite in _additionalSprites)
            {
                
                if (additionalSprite.rect == LDtkCoordConverter.ImageSlice(smallRect, textureHeight))
                {
                    return additionalSprite;
                }
            }
            return null;
        }

        private void ScaleUp(ref Rect rect)
        {
            if (_overrideTextureMultiplier == 1)
            {
                return;
            }
            rect.x *= _overrideTextureMultiplier;
            rect.y *= _overrideTextureMultiplier;
            rect.width *= _overrideTextureMultiplier;
            rect.height *= _overrideTextureMultiplier;
        }

        private void ScaleDown(ref Rect rect)
        {
            if (_overrideTextureMultiplier == 1)
            {
                return;
            }
            rect.x /= _overrideTextureMultiplier;
            rect.y /= _overrideTextureMultiplier;
            rect.width /= _overrideTextureMultiplier;
            rect.height /= _overrideTextureMultiplier;
        }
    }
}